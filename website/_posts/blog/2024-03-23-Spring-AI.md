---
layout: post
title: "Exploring Spring AI: Building a Simple Hotel Booking Agent"
category: blog
tags: Spring AI LLM Agent java AI function
---

I recently came across the [Spring AI](https://docs.spring.io/spring-ai/reference/index.html) project, which "aims to 
streamline the development of applications that incorporate artificial intelligence functionality without unnecessary complexity."

Thus far, I've been relying on the [LangChain4J]() Framework for my AI projects, but as a Java developer & Spring enthusiast, 
I was excited to see what Spring AI had to offer. Unfortunately, at the time of writing, the latest stable release `0.8.1`
does not support function calling, which is critical for most advanced use cases. As such, I will be working using the unstable 
`1.0.0-SNAPSHOT`

**Today's Project:** Today We will be building a simple Spring AI agent that will help manage a dummy hotel booking system.

I'm going to keep this project simple and focus more on utilizing the Spring AI framework rather than building a bullet-proof,
production ready Agent. All the code will be available on my [GitHub]()

## Concepts

Before we begin, I want to provide a quick refresher on some of the key concepts in AI/LLM development.

## Getting Started

### Dependencies

Before adding the Spring AI dependency to your project, you will need to add the Spring AI Snapshot repository to your `pom.xml` file.

```xml
    <repositories>
        <repository>
            <id>spring-snapshots</id>
            <name>Spring Snapshots</name>
            <url>https://repo.spring.io/snapshot</url>
            <releases>
                <enabled>false</enabled>
            </releases>
        </repository>
    </repositories>
```

Once that is added, we'll now be able to access the `1.0.0-SNAPSHOT` version of Spring AI--which is reported as unstable,
but does support function calling.

Next, we'll add the Spring AI dependency to our `pom.xml` file.

```xml
    <dependency>
        <groupId>org.springframework.experimental</groupId>
        <artifactId>spring-ai</artifactId>
        <version>1.0.0-SNAPSHOT</version>
    </dependency>
```

### Credentials

I'll be using OpenAI for this project. The Spring-AI framework allows us to create an entry in our `application.properties` file:

`spring.ai.openai.api-key=${OPENAI_API_KEY}`

I'm setting an environment variable `OPENAI_API_KEY` to my OpenAI API key in my Run Configuration.

### Sanity Check

Now that our dependencies are set up, let's do a quick sanity check to ensure that everything is working as expected.

The following code snippet was pulled directly from the Spring AI documentation:

```java
@RestController
public class SimpleAiController {

    private final ChatClient chatClient;

    @Autowired
    public SimpleAiController(ChatClient chatClient) {
        this.chatClient = chatClient;
    }

    @GetMapping("/ai/simple")
    public Map<String, String> completion(@RequestParam(value = "message", defaultValue = "Tell me a joke") String message) {
        return Map.of("generation", chatClient.call(message));
    }
}
```

With my application running, I want to test the endpoint by sending a `GET` request to `http://localhost:8080/ai/simple`

```shell
/tmp ❯ curl http://localhost:8080/ai/simple
{"generation":"Why did the scarecrow win an award?\nBecause he was outstanding in his field!"}%
```

Looks like we're in business! Now we can move on to building our Hotel Booking Agent.

**Note:** Thus far, this is all the code required. The Spring-AI framework was able to configure and autowire the
ChatClient for us using the API key we provided in the `application.properties` file. `LangChain4J` requires a bit more
configuration to get started.

## Creating the Hotel Booking Agent

The hotel booking agent will be a simple agent that can handle the following commands:

* check availability
* book a room
* cancel a booking

We will be using a simple in-memory data store to manage both the hotel bookings and the conversation context. I mentioned
earlier that this exploration is more about the Spring AI framework than building a production-ready agent, so we will
only support a single conversation at a time.

### Booking Service and Function Calls

I've created a simple booking service that will manage the hotel bookings. While I will spare you the details of its implementation
as it is not the focus of this post, I do want to point out some conditions I've set up for the service:

```java
    /**
     * Initializes the availability of rooms for specific dates for demonstration purposes.
     */
    @PostConstruct
    public void init() {
        // Set availability for January 15, 2025 (available)
        LocalDate availableDate = LocalDate.of(2025, 1, 15);
        setAvailability(availableDate, 5);

        // Set availability for February 28, 2025 (unavailable)
        LocalDate unavailableDate = LocalDate.of(2025, 2, 28);
        setAvailability(unavailableDate, 0);
    }
```

While the service exposes methods to check availability, book a room, and cancel a booking, the LLM Agent will not be able 
to interact with the service directly. In order to wire up the service to the LLM Agent, we will need to define a function
and expose it to the LLM Agent.

In the official Spring AI function calling documentation, they provide the following example:

```java
public class MockWeatherService implements Function<Request, Response> {

	public enum Unit { C, F }
	public record Request(String location, Unit unit) {}
	public record Response(double temp, Unit unit) {}

	public Response apply(Request request) {
		return new Response(30.0, Unit.C);
	}
}
```

The above is supposed to wrap a 3rd party service. After spending some time reading the documentation and source code, I was
unable to find a way to expose multipe methods on a service without creating multiple classes. I was really hoping that
exposing a service call would be as simple as a `@Tool` annotation on a method, like in the `LangChain4J` framework.

#### Booking Tools

We will define a function that will expose a single method call on the HotelBookingService to the Agent.

```java
@Component
@RequiredArgsConstructor
public class CheckAvailabilityTool implements Function<CheckAvailabilityTool.Request, CheckAvailabilityTool.Response> {

    private final HotelBookingService hotelBookingService;

    public record Request(String date) {}
    public record Response(boolean available) {}

    @Override
    public Response apply(Request request) {
        // LocalDate from a string
        LocalDate date = LocalDate.parse(request.date);
        Boolean isAvailable = hotelBookingService.isAvailable(date);

        return new Response(isAvailable);
    }

}
```

To test this out, I've modified the `SimpleAiController` to test it out, here's how it looks now:

```java
@RestController
public class SimpleAiController {

    private final ChatClient chatClient;
    private final CheckAvailabilityTool checkAvailabilityTool;

    @Autowired
    public SimpleAiController(ChatClient chatClient, CheckAvailabilityTool checkAvailabilityTool) {
        this.chatClient = chatClient;
        this.checkAvailabilityTool = checkAvailabilityTool;
    }

    @GetMapping("/ai/simple")
    public Map<String, String> completion(@RequestParam(value = "message", defaultValue = "Do you have any rooms available on February 28, 2025") String message) {

        UserMessage userMessage = new UserMessage(message);

        var promptOptions = OpenAiChatOptions.builder()
                .withFunctionCallbacks(List.of(FunctionCallbackWrapper.builder(checkAvailabilityTool)
                        .withName("CheckAvailability")
                        .withDescription("Check the availability of rooms for a specific date")
                        .withResponseConverter((response) -> "" + response.available())
                        .build()))
                .build();

        ChatResponse response = chatClient.call(new Prompt(List.of(userMessage), promptOptions));
        return Map.of("generation", response.getResult().toString());
    }
}
```

You can see that the ChatClient/LLM is now aware of the `CheckAvailabilityTool` function. I've also updated the default
message value to include a date that is set to be unavailable in the `HotelBookingService`.

Let's test it out:

```shell
/tmp ❯ curl http://localhost:8080/ai/simple
{"generation":"Generation{assistantMessage=AssistantMessage{content='I'm sorry, but we do not have any rooms available on February 28, 2025.', properties={role=ASSISTANT, finishReason=STOP, id=chatcmpl-9658XUpnLnRKZ2LUlbk4DbF00WBBV}, messageType=ASSISTANT}, chatGenerationMetadata=org.springframework.ai.chat.metadata.ChatGenerationMetadata$1@642222bf}"}
```

Perfect! The LLM was able to call the `CheckAvailabilityTool` function and respond accordingly. I will continue to build
wrapper functions for the `BookRoom` and `CancelBooking` methods in the `HotelBookingService`.

#### Chat Management

Spring AI doesn't appear to provide a mechanism OOTB for managing the conversation context. I will be using a simple in-memory
using another singleton scoped spring service to manage a single conversation. 

**Note:** With LLM APIs they generally do not manage any of the conversation context. This is typically handled by the client,
which will save all relevant messages & provide them upon each request for the model to generate a response.

Below is the simple ConversationService I've created:

```java
@Service
@Scope("singleton")
@Slf4j
public class ConversationService {
    private List<Message> messageList = Collections.synchronizedList(new ArrayList<>());

    /**
     * Adds a message to the conversation.
     *
     * @param message the message to be added to the conversation
     * @return the updated list of messages in the conversation
     */
    public synchronized List<Message> addMessage(Message message) {
        messageList.add(message);
        log.info("Added message to conversation: {}, total messages: {}", message, messageList.size());
        return new ArrayList<>(messageList);
    }

    /**
     * Retrieves all messages in the conversation.
     *
     * @return the list of messages in the conversation
     */
    public synchronized List<Message> getAllMessages() {
        log.info("Retrieved all {} messages", messageList.size());
        return new ArrayList<>(messageList);
    }
}
```

In a real world application, this would be replaced with a more robust solution, such as Redis or a database--and would
support concurrent conversations. As this is written, it will only save the context of our current conversation.